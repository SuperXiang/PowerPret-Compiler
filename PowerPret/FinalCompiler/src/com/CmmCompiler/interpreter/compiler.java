/* Generated By:JJTree&JavaCC: Do not edit this line. compiler.java */
package com.CmmCompiler.interpreter;
import java.util.*;
import java.io.*;

/**
*
* @author  PowerPret
* @function compiler.java
*/

public class compiler/*@bgen(jjtree)*/implements compilerTreeConstants, compilerConstants {/*@bgen(jjtree)*/
  protected static JJTcompilerState jjtree = new JJTcompilerState();public static FileInputStream fileStream;
 // 	private static Token tk;
//	private static String errorMsg="";
  //public static int scope=0;

static  Token tk;
static  String errorMsg="";

        public static void error(String message) {
                errorMsg += tk.beginLine + " \u884c  " + tk.beginColumn + " \u5217      "
                                + message + "\n";
                // UserGraphic.println(token.getRow() + "行 " + token.getColumn()
                // +"列     "+ message);
        }

        public static String getErrorMsg() {
                return errorMsg;
        }
 // public static void main(String args[]) throws Exception {
        //	try {
                  //建立parser对象，调用lexical方法对test.cmm进行第一次扫描，并完成词法分析
        //		fileStream = new FileInputStream("test.cmm");
        //	  	compiler parser = new compiler(fileStream);
        //	  	parser.Lexical();
        //	  	fileStream.close();
        //	  	
        //	  //重新初始化parser对象，对test.cmm进行第二次扫描，完成语法及语义分析，打印语法树和符号表，并将运行结果显示在model-console中
        //	  	fileStream = new FileInputStream("test.cmm");
        //	  	parser.ReInit(fileStream);
        //	  	System.out.println("Start syntactical and semantic analyzing......");
        //	  	SimpleNode n = parser.Start();
        //	  	//先建立syntactical_result文件，否则会再dump时报错
        //	  	FileWriter SynFWriter = new FileWriter("Syntactical_result.txt");
        //		SynFWriter.write("");
        //		SynFWriter.close();
        //		n.dump("");
        //		System.out.println("Syntactical_result.txt generated!");
        //		execute exe = new execute(n);
        //		exe.walk();
        //		PrintStream table_stream = new PrintStream(new FileOutputStream("VarTable.txt"));
        //		table_stream.print(exe.varTable.toString());
        //		System.out.println("VarTable.txt generated!");
        //		fileStream.close();  			
        //		
        //	} catch (FileNotFoundException e) {
        //		// TODO Auto-generated catch block
        //		e.printStackTrace();
        //	}
 // }

  private static String[] TokenKindImg={
"", null, null, null, null, null, null, null, null, "\"KWIF\"",
"\"KWELSE\"", "\"KWWHILE\"", "\"KWBREAK\"", "\"KWREAD\"",
"\"KWWRITE\"", "\"KWINT\"", "\"KWDOUBLE\"", "\"KWBOOLEAN\"","\"KWSWITCH\"","\"KWCASE\"","\"KWDEFAULT\"", "\"PLUS\"", "\"MINUS\"",
"\"MULTIPLY\"", "\"DIVIDE\"", "\"MOD\"", "\"LESS_THAN\"", "\"GREATER_THAN\"", "\"LESS_EQUAL\"", "\"GREATER_EQUAL\"", "\"EQUAL\"", "\"NOT_EQUAL\"", "\"ASSIGNMENT\"",
"\"LPARENTHESIS\"", "\"RPARENTHESIS\"", "\"LBRACKET\"", "\"RBRACKET\"", "\"LBLOCK\"", "\"RBLOCK\"", "\"COMMA\"","\"COLON\"", "\"EOL\"", "\"INTEGER_CONSTANT\"", "\"DOUBLE_CONSTANT\"", "\"BOOLEAN_CONSTANT\"", null,
"\"IDENTIFIER\"", null, };


  public final String Lexical()throws FileNotFoundException{
                compilerTokenManager TokenManager=this.token_source;
        //	FileOutputStream lexFOStream = new FileOutputStream("Lexical_result.txt");
        //	PrintStream Lexical_Stream = new PrintStream(lexFOStream);
        //	System.out.println("Start lexical analyzing......");
                String result="";
                String errMsg="";
                String lexical="";
                String sentence="";
                int Line=0;
                Token t;
                lexicalLOOP:
                while(true){
                  try{
                    t=TokenManager.getNextToken();
                  }     catch(TokenMgrError e){
                    errMsg += e.toString()+"\r\n";
                    try {
                      TokenManager.input_stream.readChar();
                      //System.out.println(TokenManager.input_stream.tokenBegin+" "+TokenManager.input_stream.bufpos+" "+TokenManager.input_stream.line+" "+TokenManager.input_stream.column);
                        } catch(IOException ex){
                                errMsg += ex.getMessage()+"\r\n";
                        }
                    continue lexicalLOOP;
                  }

                  if(Line!=0&&Line!=t.beginLine){
                    sentence+="\r\n";
                    result += sentence+lexical;
                    Line=t.beginLine;
                    sentence = "Line:"+Line;
                    lexical = "";
                  } else if(Line==0){
                    Line = t.beginLine;
                    sentence="Line:"+Line;
                  }
                  if(t.specialToken != null){
                    Token tmp_t = t.specialToken;
                        while (tmp_t.specialToken != null) tmp_t = tmp_t.specialToken;

                        while (tmp_t != null) {
                            result += tmp_t.image+"\r\n";
                            tmp_t = tmp_t.next;
                        }
                  }

                  sentence += " "+t.image;
                  if(t.kind==0){
                    break;
                  }
                  if(TokenKindImg[t.kind]==null)lexical+="\t(Line:"+t.beginLine+":"+"\t"+t.image+")"+"  ";
                  else lexical+="\t(Line:"+t.beginLine+":"+"\t"+TokenKindImg[t.kind]+"\t"+t.image+")"+"  ";
                  lexical+="\r\n";
                  //System.out.println("(\t"+t.image+"\t"+t.kind+"\t)");
                }
                //System.out.println("Line:"+Line+sentence);
                //System.out.println(lexical);
//		Lexical_Stream.print(result+errMsg);
//		System.out.println("Lexical_result.txt generated!");
                return result;
  }

  public final String Lexicaler()throws FileNotFoundException{
                compilerTokenManager TokenManager=this.token_source;
        //	FileOutputStream lexFOStream = new FileOutputStream("Lexical_result.txt");
        //	PrintStream Lexical_Stream = new PrintStream(lexFOStream);
        //	System.out.println("Start lexical analyzing......");
                String result="";
                String errMsg="";
                String lexical="";
                String sentence="";
                int Line=0;
                Token t;
                lexicalLOOP:
                while(true){
                  try{
                    t=TokenManager.getNextToken();
                  }     catch(TokenMgrError e){
                    errMsg += e.toString()+"\r\n";
                    try {
                      TokenManager.input_stream.readChar();
                      //System.out.println(TokenManager.input_stream.tokenBegin+" "+TokenManager.input_stream.bufpos+" "+TokenManager.input_stream.line+" "+TokenManager.input_stream.column);
                        } catch(IOException ex){
                                errMsg += ex.getMessage()+"\r\n";
                        }
                    continue lexicalLOOP;
                  }

                  if((Line!=0&&Line!=t.beginLine)||t.kind==0){
                    sentence+="\r\n";
                    result += sentence+lexical;
                    Line=t.beginLine;
                    sentence = "Line:"+Line;
                    lexical = "";
                  } else if(Line==0){
                    Line = t.beginLine;
                    sentence="Line:"+Line;
                  }
                  if(t.specialToken != null){
                    Token tmp_t = t.specialToken;
                        while (tmp_t.specialToken != null) tmp_t = tmp_t.specialToken;

                        while (tmp_t != null) {
                            result += tmp_t.image+"\r\n";
                            tmp_t = tmp_t.next;
                        }
                  }

                  sentence += " "+t.image;
                  if(t.kind==0){
                    break;
                  }
                  if(TokenKindImg[t.kind]==null)lexical+="\t(Line:"+t.beginLine+":"+"\t"+t.image+")"+"  ";
                  else lexical+="\t(Line:"+t.beginLine+":"+"\t"+TokenKindImg[t.kind]+"\t"+t.image+")"+"  ";
                  lexical+="\r\n";
                  //System.out.println("(\t"+t.image+"\t"+t.kind+"\t)");
                }
                //System.out.println("Line:"+Line+sentence);
                //System.out.println(lexical);
//		Lexical_Stream.print(result+errMsg);
//		System.out.println("Lexical_result.txt generated!");
                return errMsg;
  }

  static final public SimpleNode Start() throws ParseException {
                      /*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      try {
        label_1:
        while (true) {
          Stmt();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case KWIF:
          case KWWHILE:
          case KWBREAK:
          case KWREAD:
          case KWWRITE:
          case KWINT:
          case KWDOUBLE:
          case KWSWITCH:
          case LBLOCK:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[0] = jj_gen;
            break label_1;
          }
        }
        jj_consume_token(0);
      } catch (ParseException e) {
    System.out.println(e.toString());
        getNextToken();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Stmt() throws ParseException {
              /*@bgen(jjtree) Stmt */
  SimpleNode jjtn000 = new SimpleNode(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KWINT:
        case KWDOUBLE:
          varDecl();
          break;
        case KWIF:
          IfStmt();
          break;
        case KWSWITCH:
          SwitchStmt();
          break;
        case KWWHILE:
          WhileStmt();
          break;
        case KWBREAK:
          BreakStmt();
          break;
        case IDENTIFIER:
          AssignStmt();
          break;
        case LBLOCK:
          StmtBlock();
          break;
        case KWREAD:
          ReadStmt();
          break;
        case KWWRITE:
          WriteStmt();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
        System.out.println(e.toString());
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != EOL);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void BreakStmt() throws ParseException {
                   /*@bgen(jjtree) BreakStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTBREAKSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(KWBREAK);
      jj_consume_token(EOL);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void StmtBlock() throws ParseException {
                   /*@bgen(jjtree) StmtBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSTMTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBLOCK);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KWIF:
        case KWWHILE:
        case KWBREAK:
        case KWREAD:
        case KWWRITE:
        case KWINT:
        case KWDOUBLE:
        case KWSWITCH:
        case LBLOCK:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        Stmt();
      }
      try {
        jj_consume_token(RBLOCK);
      } catch (ParseException e) {
      error("Warning: No matched block found at line " + e.currentToken.next.beginLine + ", column " + e.currentToken.next.beginColumn);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

////////////////////////////////////////
//Definition of Variable Declaration
  static final public void varDecl() throws ParseException {
                 /*@bgen(jjtree) varDecl */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Type();
      VarList();
      jj_consume_token(EOL);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Type() throws ParseException {
 /*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String type;
  String length;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KWINT:
        jj_consume_token(KWINT);
    type = "integer";
    jjtn000.jjtSetValue(type);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          tk = jj_consume_token(INTEGER_CONSTANT);
          jj_consume_token(RBRACKET);
        if( Integer.parseInt(tk.image)<0)
        {
                error("Index Should Be Positive Number! \n");
        }
        else{
    length = tk.image;
    jjtn000.jjtSetValue(length);
        }
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        break;
      case KWDOUBLE:
        jj_consume_token(KWDOUBLE);
    type = "double";
    jjtn000.jjtSetValue(type);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          tk = jj_consume_token(INTEGER_CONSTANT);
          jj_consume_token(RBRACKET);
    if( Integer.parseInt(tk.image)<0)
        {
                error("Index Should Be Positive Number! \n");
        }
        else{
    length = tk.image;
    jjtn000.jjtSetValue(length);
        }
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void VarList() throws ParseException {
 /*@bgen(jjtree) VarList */
  SimpleNode jjtn000 = new SimpleNode(JJTVARLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);//Token node;
  String name;
  tempNote note;
    try {
      tk = jj_consume_token(IDENTIFIER);
        name = tk.image;
        jjtn000.jjtSetValue(name);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGNMENT:
        jj_consume_token(ASSIGNMENT);
        Expression();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        tk = jj_consume_token(IDENTIFIER);
        if((tk.image=="_")||(tk.image=="0")||(tk.image=="1")||(tk.image=="2")||(tk.image=="3")||(tk.image=="4")||(tk.image=="5")||(tk.image=="6")||(tk.image=="7")||(tk.image=="8")||(tk.image=="9")||((tk.image=="a")&&(tk.next.image=="_"))){
                error("Virable Declaration Error! \n");
        }
        else{
        name = tk.image;
        jjtn000.jjtSetValue(name);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGNMENT:
          jj_consume_token(ASSIGNMENT);
          Expression();
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

////////////////////////////////////////
//Definition of If-Clause
  static final public void IfStmt() throws ParseException {
                /*@bgen(jjtree) IfStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTIFSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(KWIF);
      jj_consume_token(LPARENTHESIS);
      Criterion();
      jj_consume_token(RPARENTHESIS);
      Stmt();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KWELSE:
        jj_consume_token(KWELSE);
        Stmt();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

///////////////////////////////////////
//Definition of Swith-Clause
  static final public void SwitchStmt() throws ParseException {
                    /*@bgen(jjtree) SwitchStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTSWITCHSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(KWSWITCH);
      jj_consume_token(LPARENTHESIS);
      Expression();
      jj_consume_token(RPARENTHESIS);
      jj_consume_token(LBLOCK);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KWCASE:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_4;
        }
        jj_consume_token(KWCASE);
        Expression();
        jj_consume_token(COLON);
        Stmt();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KWDEFAULT:
        jj_consume_token(KWDEFAULT);
        jj_consume_token(COLON);
        Stmt();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(RBLOCK);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

///////////////////////////////////////
//Definition of Criterion
  static final public void Criterion() throws ParseException {
 /*@bgen(jjtree) Criterion */
  SimpleNode jjtn000 = new SimpleNode(JJTCRITERION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String type;
    try {
      Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS_THAN:
      case GREATER_THAN:
      case LESS_EQUAL:
      case GREATER_EQUAL:
      case EQUAL:
      case NOT_EQUAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GREATER_THAN:
          jj_consume_token(GREATER_THAN);
          jjtn000.jjtSetValue(">");
          break;
        case LESS_THAN:
          jj_consume_token(LESS_THAN);
          jjtn000.jjtSetValue("<");
          break;
        case EQUAL:
          jj_consume_token(EQUAL);
          jjtn000.jjtSetValue("==");
          break;
        case NOT_EQUAL:
          jj_consume_token(NOT_EQUAL);
          jjtn000.jjtSetValue("!=");
          break;
        case GREATER_EQUAL:
          jj_consume_token(GREATER_EQUAL);
          jjtn000.jjtSetValue(">=");
          break;
        case LESS_EQUAL:
          jj_consume_token(LESS_EQUAL);
          jjtn000.jjtSetValue("<=");
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

///////////////////////////////////////////
//Definition of While-Clause
  static final public void WhileStmt() throws ParseException {
                   /*@bgen(jjtree) WhileStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILESTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(KWWHILE);
      jj_consume_token(LPARENTHESIS);
      Criterion();
      jj_consume_token(RPARENTHESIS);
      Stmt();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//////////////////////////////////////////
//Definition of Read-Clause
  static final public void ReadStmt() throws ParseException {
                  /*@bgen(jjtree) ReadStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTREADSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(KWREAD);
      jj_consume_token(LPARENTHESIS);
      Value();
      jj_consume_token(RPARENTHESIS);
      jj_consume_token(EOL);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//////////////////////////////////////////
//Definition of Write-Clause
  static final public void WriteStmt() throws ParseException {
                   /*@bgen(jjtree) WriteStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTWRITESTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(KWWRITE);
      jj_consume_token(LPARENTHESIS);
      Expression();
      jj_consume_token(RPARENTHESIS);
      jj_consume_token(EOL);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//////////////////////////////////////////
//Definition of Assignment
  static final public void AssignStmt() throws ParseException {
                    /*@bgen(jjtree) AssignStmt */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Value();
      jj_consume_token(ASSIGNMENT);
      Expression();
      jj_consume_token(EOL);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Value() throws ParseException {
 /*@bgen(jjtree) Value */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String name;
  String length;
    try {
      tk = jj_consume_token(IDENTIFIER);
  //	if(node.image!="int" || node.image!="double" || node.image!="real"){
  //		error("Invalid Type! \n");
  //	}
  //	else{
        name = tk.image;
        jjtn000.jjtSetValue(name);
 // }

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        jj_consume_token(LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_CONSTANT:
          tk = jj_consume_token(INTEGER_CONSTANT);
        if( Integer.parseInt(tk.image)<0)
        {
                error("Index Should Be Positive Number! \n");
        }
        else //if(Integer.parseInt(node.image)>=0){
        {
        length = tk.image;
        jjtn000.jjtSetValue(length);
        }
          break;
        case MINUS:
        case LPARENTHESIS:
        case DOUBLE_CONSTANT:
        case IDENTIFIER:
          Expression();
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RBRACKET);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

///////////////////////////////////////////
//Comment
//void Comment() :{}
//{
//	"/*"tk=< WithinComment>"*/"
//	{
//		if(tk.image=="/*"||tk.image=="*/")
//		 error("Duplicated Comment Signs! \n");
//	}
//	
//}

///////////////////////////////////////////
//Definition of Expression
  static final public void Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String type;
    try {
      Term();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
        type="+";
        jjtn000.jjtSetValue(type);
          break;
        case MINUS:
          jj_consume_token(MINUS);
        type="-";
        jjtn000.jjtSetValue(type);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Term();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Term() throws ParseException {
 /*@bgen(jjtree) Term */
  SimpleNode jjtn000 = new SimpleNode(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String type;
    try {
      Element();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
        case DIVIDE:
        case MOD:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
          jj_consume_token(MULTIPLY);
        type="*";
        jjtn000.jjtSetValue(type);
          break;
        case DIVIDE:
          jj_consume_token(DIVIDE);
        type="/";
        jjtn000.jjtSetValue(type);
          break;
        case MOD:
          jj_consume_token(MOD);
        type="%";
        jjtn000.jjtSetValue(type);
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Element();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Element() throws ParseException {
 /*@bgen(jjtree) Element */
  SimpleNode jjtn000 = new SimpleNode(JJTELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String type;
  Token node;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
        Element();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        type="minus";
        jjtn000.jjtSetValue(type);
        break;
      case INTEGER_CONSTANT:
        node = jj_consume_token(INTEGER_CONSTANT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        type="integer";
        jjtn000.jjtSetValue(type);
        jjtn000.jjtSetValue(node.image);
        break;
      case DOUBLE_CONSTANT:
        node = jj_consume_token(DOUBLE_CONSTANT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
        type="double";
        jjtn000.jjtSetValue(type);
        jjtn000.jjtSetValue(node.image);
        break;
      case LPARENTHESIS:
        jj_consume_token(LPARENTHESIS);
        Expression();
        jj_consume_token(RPARENTHESIS);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
        type="expression";
        jjtn000.jjtSetValue(type);
        break;
      case IDENTIFIER:
        Value();
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
        type="value";
        jjtn000.jjtSetValue(type);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static private boolean jj_initialized_once = false;
  static public compilerTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[21];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x5fa00,0x5fa00,0x5fa00,0x0,0x0,0x18000,0x0,0x0,0x0,0x400,0x80000,0x100000,0xfc000000,0xfc000000,0x400000,0x0,0x600000,0x600000,0x3800000,0x3800000,0x400000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x4020,0x4020,0x4020,0x8,0x8,0x0,0x1,0x80,0x1,0x0,0x0,0x0,0x0,0x0,0x4c02,0x8,0x0,0x0,0x0,0x0,0x4c02,};
   }

  public compiler(java.io.InputStream stream) {
     this(stream, null);
  }
  public compiler(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new compilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
  }

  public compiler(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new compilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
  }

  public compiler(compilerTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
  }

  public void ReInit(compilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[48];
    for (int i = 0; i < 48; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 21; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 48; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
